<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursividad</title>
    <link rel="stylesheet" href="./css blogs/recursion.css"> <!-- Ajusta la ruta si es necesario -->
    <link rel="icon" href="../assets/favicon.ico"type="image/png">
</head>
<body>
    <header>
        <h1>Recursividad</h1>
    </header>

    <main class="container-recursividad">
        <article>
            <h2>쯈u칠 es la recursividad?</h2>
            <p>En t칠rminos simples, es algo que ocurre cuando "algo" se invoca a s칤 mismo. Si hablas con un inform치tico, te va a decir que es cuando una funci칩n es llamada a s칤 misma. 
                Pero, es una respuesta algo limitada.
                <br>
                Es una forma de resolver problemas, una nueva forma de pensar. Es la idea de definir entidades en t칠rminos de s칤 mismos.
                <br>
                En el colegio nos dec칤an que, si quer칤as definir un concepto, no pod칤as utilizar esa misma palabra dentro de la definici칩n. La recursividad es justamente eso.</p>
        

        
            <h3>El caso base</h3>
            <p>Cuando uno quiere dise침ar un algoritmo de manera recursiva, como un m칠todo se va a invocar a s칤 mismo, no puede hacerlo infinitas veces, en alg칰n momento se debe detener.
                 Bueno, el algoritmo para en estos llamados casos base.
                 <br>
                Son instancias del problema que se pueden resolver de manera inmediata sin necesidad de invocar a la funci칩n. Son aquellos casos m치s sencillos en los que no se necesita aplicar la recursividad.</p>
        

        
            <h3>Veamos un ejemplo: la funci칩n factorial</h3>
            <p>Indicamos el factorial de n como n!. Es el producto de los enteros desde 1 hasta n. Por ejemplo:

                5! = 1 * 2 * 3 * 4 * 5 = 120.
                <br>

                
                La funci칩n factorial es muy 칰til cuando queremos contar de cu치ntas maneras diferentes podemos ordenar o combinar cosas. Por ejemplo, el n칰mero de formas en que se pueden acomodar n elementos es:
                
                n! = n * (n - 1) * (n - 2) * ... * 2 * 1.
                <br>

                
                Un punto interesante es la definici칩n de 0!. Como no hay enteros mayores o iguales que 1 y menores o iguales que 0, se define que 0! = 1 por convenci칩n matem치tica y por coherencia con otras f칩rmulas combinatorias.
            </p>
       

        
            <h3>Divide y conquistar치s</h3>
            <p>Cuando dise침amos un algoritmo recursivo, seguimos estos pasos:
                <br>
                Definir el caso base.
                <br>
                Aplicar el concepto de inducci칩n.
                
                La idea de inducci칩n consiste en construir la soluci칩n de un problema a partir de soluciones a problemas m치s sencillos. Por ejemplo, si queremos ordenar una lista de n elementos, podemos resolver el problema para n - 1 elementos y extender la soluci칩n.
                
                La clave est치 en elegir bien los subproblemas para acercarnos al caso base.
                <br>
                Podemos dividir el problema en n-1, n-2, o cualquier subproblema v치lido que simplifique la soluci칩n.</p>
        

       
            <h3>Recursi칩n o Iteraci칩n?</h3>
            <p>Dado que la recursi칩n es una forma alternativa de pensar, surge la pregunta: 쮺u치ndo es mejor usar recursi칩n y cu치ndo iteraci칩n?

                Cualquier algoritmo iterativo puede transformarse en recursivo y viceversa. Sin embargo, algunas recomendaciones son:
                <br>
                Si el problema involucra estructuras de datos lineales como arrays o matrices, los algoritmos iterativos suelen ser m치s eficientes.
                <br>
                Si el problema tiene una estructura de 치rbol o grafo, la recursi칩n suele ser una mejor opci칩n.
                <br>
                Si la funci칩n recursiva solo contiene una llamada recursiva (recursi칩n lineal), la iteraci칩n puede ser m치s eficiente.
                <br>
                Sin embargo, la recursi칩n puede generar problemas de memoria si hay demasiadas llamadas anidadas, lo que puede provocar un stack overflow (desbordamiento de pila). Por eso, en procesos lineales con muchas llamadas, la iteraci칩n suele ser preferible.
                <br>
                Si un algoritmo tiene dos o m치s llamados recursivos, es recomendable usar recursividad, ya que el c칩digo suele ser m치s claro y conciso.
                <br>
                En definitiva, elegir entre recursi칩n e iteraci칩n depende del problema y de la eficiencia deseada. 춰La clave est치 en analizar bien la estructura del problema! 游</p>
        </article>
    </main>

    <footer>
        <p>&copy; 2025 - Santiago Centurion Cohen</p>
    </footer>
</body>
</html>
